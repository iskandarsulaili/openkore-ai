"""
Solution Agent - Intelligent Fix Generation
Generates context-aware solutions based on character state, game version, and activity
Enhanced for Phase 31 OpenKore critical issues
"""

from crewai import Agent
from crewai.tools import BaseTool
from typing import Dict, List, Any
from pathlib import Path
import re
import logging
from pydantic import ConfigDict


class AdaptiveSolutionGeneratorTool(BaseTool):
    """Tool for generating adaptive solutions based on context"""
    
    model_config = ConfigDict(
        extra='allow',
        arbitrary_types_allowed=True
    )
    
    name: str = "solution_generator"
    description: str = "Generate intelligent fixes adapted to character level, class, map, and detected issue"
    
    def __init__(self, knowledge_base, solution_config: Dict):
        super().__init__()
        self.kb = knowledge_base
        self.config = solution_config
        self.logger = logging.getLogger('autonomous_healing.solution_agent')
    
    def _run(self, issue: Dict, analysis: Dict, character_context: Dict) -> Dict[str, Any]:
        """Generate adaptive solution based on issue and context"""
        try:
            issue_type = issue.get('type')
            solutions = []
            
            self.logger.info(f"Generating solution for issue type: {issue_type}")
            
            # Get similar past solutions from knowledge base
            past_solutions = self.kb.get_similar_solutions(issue_type)
            base_confidence = past_solutions[0]['confidence'] if past_solutions else 0.5
            
            # PHASE 31 CRITICAL ISSUES
            
            # Issue 1: Missing auto-heal configuration
            if issue_type == 'missing_auto_heal' or issue_type == 'missing_useSelf_item':
                healing_items = issue.get('healing_items', issue.get('available_items', []))
                self.logger.critical(f"Generating useSelf_item configuration for items: {healing_items}")
                
                # Generate useSelf_item blocks for each healing item
                changes = []
                for item in healing_items:
                    item_name = item.strip()
                    # Check if it's Apple or Potion
                    if 'Apple' in item_name:
                        changes.append({
                            'type': 'append',
                            'content': f'\n# Auto-heal with {item_name} (generated by autonomous healing)\n'
                                      f'useSelf_item {item_name} {{\n'
                                      f'    hp < 50%\n'
                                      f'    disabled 0\n'
                                      f'}}\n',
                            'reason': f'Adding auto-heal configuration for {item_name} to prevent death'
                        })
                    elif 'Potion' in item_name:
                        # Different threshold for potions
                        changes.append({
                            'type': 'append',
                            'content': f'\n# Auto-heal with {item_name} (generated by autonomous healing)\n'
                                      f'useSelf_item {item_name} {{\n'
                                      f'    hp < 60%\n'
                                      f'    disabled 0\n'
                                      f'}}\n',
                            'reason': f'Adding auto-heal configuration for {item_name} to prevent death'
                        })
                
                if changes:
                    solutions.append({
                        'action': 'add_useSelf_item_blocks',
                        'file': 'openkore-ai/control/config.txt',
                        'changes': changes,
                        'confidence': 0.95,
                        'requires_approval': False,
                        'priority': 'CRITICAL'
                    })
                    self.logger.info(f"Generated {len(changes)} useSelf_item configurations")
            
            # Issue 2: Teleport spam (no teleport skill/fly wings)
            elif issue_type == 'teleport_spam' or issue_type == 'teleportAuto_misconfigured':
                current_value = issue.get('current_value', 10)
                self.logger.critical(f"Disabling teleportAuto (currently {current_value}) - bot lacks teleport capability")
                
                solutions.append({
                    'action': 'disable_teleportAuto',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'teleportAuto_hp\s+\d+',
                            'replacement': 'teleportAuto_hp 0',
                            'reason': 'Disabling teleportAuto - bot has no Teleport skill or Fly Wings'
                        },
                        {
                            'type': 'comment',
                            'pattern': r'teleportAuto_hp',
                            'comment': '# DISABLED by autonomous healing - no teleport capability',
                            'reason': 'Adding comment for clarity'
                        }
                    ],
                    'confidence': 0.98,
                    'requires_approval': False,
                    'priority': 'CRITICAL'
                })
                self.logger.info("Generated solution to disable teleportAuto")
            
            # Issue 3: Inappropriate thresholds (sitAuto too high)
            elif issue_type == 'inappropriate_sitAuto_threshold':
                current_value = issue.get('current_value', 85)
                char_level = character_context.get('level', 6)
                
                # Adaptive threshold based on level
                if char_level <= 10:
                    recommended = 50  # Low-level bots should be aggressive
                elif char_level <= 30:
                    recommended = 60
                else:
                    recommended = 70
                
                self.logger.warning(f"Adjusting sitAuto_hp_lower from {current_value} to {recommended} for level {char_level}")
                
                solutions.append({
                    'action': 'adjust_sitAuto_threshold',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'sitAuto_hp_lower\s+\d+',
                            'replacement': f'sitAuto_hp_lower {recommended}',
                            'reason': f'Adjusting threshold from {current_value} to {recommended} for level {char_level} efficiency'
                        }
                    ],
                    'confidence': 0.85,
                    'requires_approval': False,
                    'priority': 'MEDIUM'
                })
                self.logger.info(f"Generated solution to adjust sitAuto to {recommended}")
            
            # Issue 4: Inefficient lockMap (too large)
            elif issue_type == 'inefficient_lockMap':
                current_area = issue.get('current_area', 22500)
                x_range = issue.get('x_range', 150)
                y_range = issue.get('y_range', 150)
                
                # Calculate optimal range (aim for ~6400 sq units = 80x80)
                optimal_range = 80
                
                self.logger.warning(f"Reducing lockMap from {x_range}x{y_range} to {optimal_range}x{optimal_range}")
                
                solutions.append({
                    'action': 'optimize_lockMap_range',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'lockMap_x\s+\d+\s+\d+',
                            'replacement': f'lockMap_x 100 {100+optimal_range}',
                            'reason': f'Reducing X range from {x_range} to {optimal_range} for efficiency'
                        },
                        {
                            'type': 'replace',
                            'pattern': r'lockMap_y\s+\d+\s+\d+',
                            'replacement': f'lockMap_y 100 {100+optimal_range}',
                            'reason': f'Reducing Y range from {y_range} to {optimal_range} for efficiency'
                        }
                    ],
                    'confidence': 0.80,
                    'requires_approval': False,
                    'priority': 'MEDIUM'
                })
                self.logger.info(f"Generated solution to optimize lockMap to {optimal_range}x{optimal_range}")
            
            # Issue 5: Unspent stat points (statsAddAuto disabled)
            elif issue_type == 'unspent_stat_points' or issue_type == 'statsAddAuto_disabled':
                stat_points = issue.get('stat_points', 17)
                char_class = character_context.get('class', 'Novice')
                
                self.logger.warning(f"Enabling statsAddAuto - {stat_points} unspent points for {char_class}")
                
                # Determine stat priorities based on class
                if char_class.lower() in ['novice', 'swordman', 'knight']:
                    stat_priority = 'STR, VIT, AGI, DEX, INT, LUK'
                elif char_class.lower() in ['archer', 'hunter']:
                    stat_priority = 'DEX, AGI, STR, VIT, INT, LUK'
                elif char_class.lower() in ['mage', 'wizard']:
                    stat_priority = 'INT, DEX, VIT, AGI, STR, LUK'
                else:
                    stat_priority = 'STR, AGI, VIT, DEX, INT, LUK'  # Default
                
                solutions.append({
                    'action': 'enable_statsAddAuto',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'statsAddAuto\s+0',
                            'replacement': 'statsAddAuto 1',
                            'reason': f'Enabling auto stat allocation for {stat_points} unspent points'
                        },
                        {
                            'type': 'append_if_missing',
                            'key': 'statsAddAuto_list',
                            'content': f'\n# Stat priorities for {char_class} (generated by autonomous healing)\n'
                                      f'statsAddAuto_list {stat_priority}\n',
                            'reason': f'Setting stat priorities for {char_class}'
                        }
                    ],
                    'confidence': 0.90,
                    'requires_approval': False,
                    'priority': 'HIGH'
                })
                self.logger.info(f"Generated solution to enable statsAddAuto with priorities: {stat_priority}")
            
            # PHASE 11 FIX: Add solution handlers for critical farming config issues
            
            # Issue 6: attackAuto disabled (bot won't attack monsters)
            elif issue_type == 'attackAuto_disabled':
                current_value = issue.get('current_value', 0)
                recommended_value = issue.get('recommended_value', 2)
                self.logger.critical(f"Enabling attackAuto from {current_value} to {recommended_value} - bot cannot farm without this!")
                
                solutions.append({
                    'action': 'enable_attackAuto',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'attackAuto\s+0',
                            'replacement': f'attackAuto {recommended_value}',
                            'reason': f'Enabling auto-attack (attackAuto {recommended_value}) to allow farming - bot cannot attack monsters without this'
                        },
                        {
                            'type': 'comment',
                            'pattern': f'attackAuto {recommended_value}',
                            'comment': f'# FIXED by autonomous healing - enabled attackAuto for farming (was: {current_value})',
                            'reason': 'Adding comment for clarity'
                        }
                    ],
                    'confidence': 0.99,
                    'requires_approval': False,
                    'priority': 'CRITICAL'
                })
                self.logger.info(f"Generated solution to enable attackAuto to {recommended_value}")
            
            # Issue 7: route_randomWalk disabled (bot won't explore for monsters)
            elif issue_type == 'route_randomWalk_disabled':
                current_value = issue.get('current_value', 0)
                recommended_value = issue.get('recommended_value', 1)
                self.logger.warning(f"Enabling route_randomWalk from {current_value} to {recommended_value} - bot won't seek monsters without this!")
                
                solutions.append({
                    'action': 'enable_route_randomWalk',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'route_randomWalk\s+0',
                            'replacement': f'route_randomWalk {recommended_value}',
                            'reason': f'Enabling random walk (route_randomWalk {recommended_value}) to allow monster exploration - bot will stand idle without this'
                        },
                        {
                            'type': 'comment',
                            'pattern': f'route_randomWalk {recommended_value}',
                            'comment': f'# FIXED by autonomous healing - enabled route_randomWalk for exploration (was: {current_value})',
                            'reason': 'Adding comment for clarity'
                        }
                    ],
                    'confidence': 0.95,
                    'requires_approval': False,
                    'priority': 'HIGH'
                })
                self.logger.info(f"Generated solution to enable route_randomWalk to {recommended_value}")
            
            # EXISTING ISSUE HANDLERS
            
            elif issue_type == 'npc_not_found' or issue_type == 'npc_interaction_failure':
                # Solution: Disable buyAuto
                self.logger.info("Disabling buyAuto due to NPC not found")
                solutions.append({
                    'action': 'disable_buyAuto',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'(buyAuto\s*\{[^}]*?)disabled\s+0',
                            'replacement': r'\1disabled 1',
                            'reason': 'NPC not found - disabling buyAuto to allow farming'
                        }
                    ],
                    'confidence': base_confidence + 0.2,
                    'requires_approval': False,
                    'priority': 'MEDIUM'
                })
            
            elif issue_type == 'lockMap_empty':
                # Solution: Set lockMap based on character level
                char_level = character_context.get('level', 1)
                char_class = character_context.get('class', 'Novice')
                
                self.logger.info(f"Setting lockMap for level {char_level} {char_class}")
                
                # Adaptive map selection
                if char_level <= 10 and char_class == 'Novice':
                    farming_map = 'prt_fild08'
                    coords_x = '100 180'
                    coords_y = '100 180'
                elif char_level <= 30:
                    farming_map = 'prt_fild05'
                    coords_x = '100 200'
                    coords_y = '100 200'
                else:
                    farming_map = 'prt_fild08'  # Default
                    coords_x = '50 150'
                    coords_y = '50 150'
                
                solutions.append({
                    'action': 'set_lockMap',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'replace',
                            'pattern': r'lockMap\s*$',
                            'replacement': f'lockMap {farming_map}',
                            'reason': f'Setting farming map for level {char_level} {char_class}'
                        },
                        {
                            'type': 'replace',
                            'pattern': r'lockMap_x\s*$',
                            'replacement': f'lockMap_x {coords_x}',
                            'reason': 'Setting X boundary for farming area'
                        },
                        {
                            'type': 'replace',
                            'pattern': r'lockMap_y\s*$',
                            'replacement': f'lockMap_y {coords_y}',
                            'reason': 'Setting Y boundary for farming area'
                        }
                    ],
                    'confidence': base_confidence + 0.25,
                    'requires_approval': True,  # Critical change
                    'priority': 'HIGH'
                })
            
            elif issue_type == 'packet_unknown':
                # Solution: Add to debugPacket_exclude
                packet_id = issue.get('packet_id', '')
                self.logger.info(f"Suppressing packet warning for {packet_id}")
                solutions.append({
                    'action': 'suppress_packet_warning',
                    'file': 'openkore-ai/control/config.txt',
                    'changes': [
                        {
                            'type': 'append_or_update',
                            'key': 'debugPacket_exclude',
                            'value': packet_id,
                            'reason': f'Suppressing warning for unknown packet {packet_id}'
                        }
                    ],
                    'confidence': base_confidence + 0.15,
                    'requires_approval': False,
                    'priority': 'LOW'
                })
            
            elif issue_type == 'death':
                # Solution: Adjust healing settings (but check if it's teleport-related first)
                death_hp = analysis.get('death_hp_percent', 0)
                
                self.logger.warning(f"Generating survival improvements for death at {death_hp}% HP")
                
                # Only adjust if death wasn't due to other known issues
                if not issue.get('critical'):  # Not death with healing items
                    solutions.append({
                        'action': 'improve_survival',
                        'file': 'openkore-ai/control/config.txt',
                        'changes': [
                            {
                                'type': 'replace',
                                'pattern': r'sitAuto_hp_lower\s+\d+',
                                'replacement': 'sitAuto_hp_lower 60',
                                'reason': 'Increasing healing threshold to prevent death'
                            }
                        ],
                        'confidence': base_confidence + 0.1,
                        'requires_approval': False,
                        'priority': 'HIGH'
                    })
            
            # Log summary
            if solutions:
                self.logger.info(f"Generated {len(solutions)} solution(s) for {issue_type}")
                for sol in solutions:
                    self.logger.debug(f"  - {sol['action']} (priority: {sol.get('priority', 'NORMAL')}, confidence: {sol['confidence']:.2f})")
            else:
                self.logger.warning(f"No solutions generated for issue type: {issue_type}")
            
            return {
                'success': True,
                'solutions_count': len(solutions),
                'solutions': solutions,
                'base_confidence': base_confidence
            }
            
        except Exception as e:
            self.logger.error(f"Failed to generate solution: {e}", exc_info=True)
            return {
                'success': False,
                'error': str(e)
            }


class SolutionAgent:
    """Wrapper for Solution Agent"""
    pass


def create_solution_agent(config: Dict, knowledge_base, solution_config: Dict, llm) -> Agent:
    """
    Create the Solution Agent for intelligent fix generation
    
    Args:
        config: Agent configuration
        knowledge_base: Knowledge base instance
        solution_config: Solution-specific configuration
        llm: LLM instance (DeepSeek via provider chain)
        
    Returns:
        Configured CrewAI Agent
    """
    
    tools = [
        AdaptiveSolutionGeneratorTool(
            knowledge_base=knowledge_base,
            solution_config=solution_config
        )
    ]
    
    # Create agent with DeepSeek LLM
    agent = Agent(
        role=config['role'],
        goal=config['goal'],
        backstory=config['backstory'],
        tools=tools,
        verbose=config.get('verbose', True),
        allow_delegation=True,
        max_iter=20,
        memory=True,
        llm=llm  # Use DeepSeek LLM
    )
    
    return agent
