package MacroHotReload;

use strict;
use warnings;
use Plugins;
use Globals;
use Log qw(message warning error);
use Utils qw(timeOut);
use Time::HiRes qw(time);
use JSON;
use IO::Socket::INET;
use IO::Select;

Plugins::register('MacroHotReload', 'Dynamic macro injection via REST API', \&on_unload);

my $hooks;
my $server_socket;
my $server_port = 8765;
my $selector;
my %macro_registry;
my %macro_stats;
my $dynamic_macro_file = 'control/eventMacros_dynamic.txt';

sub on_load {
	$hooks = Plugins::addHooks(
		['mainLoop_pre', \&check_http_requests],
		['macro_execution', \&track_macro_execution]
	);
	
	# Create HTTP server socket (non-blocking)
	$server_socket = IO::Socket::INET->new(
		LocalHost => '127.0.0.1',
		LocalPort => $server_port,
		Listen => 5,
		ReuseAddr => 1,
		Blocking => 0
	);
	
	if (!$server_socket) {
		error "[MacroHotReload] Failed to create HTTP server on port $server_port: $!\n";
		return;
	}
	
	$selector = IO::Select->new($server_socket);
	
	# Initialize dynamic macro file if it doesn't exist
	unless (-f $dynamic_macro_file) {
		open my $fh, '>', $dynamic_macro_file or die "Cannot create $dynamic_macro_file: $!";
		print $fh "# Dynamic Macros - Generated by MacroHotReload Plugin\n";
		print $fh "# This file is automatically managed. Do not edit manually.\n\n";
		close $fh;
	}
	
	message "[MacroHotReload] HTTP server started on http://127.0.0.1:$server_port\n";
	message "[MacroHotReload] Endpoints available:\n";
	message "[MacroHotReload]   POST   /macro/inject\n";
	message "[MacroHotReload]   DELETE /macro/delete\n";
	message "[MacroHotReload]   GET    /macro/list\n";
	message "[MacroHotReload]   GET    /macro/stats\n";
	message "[MacroHotReload] Plugin loaded successfully\n";
}

sub check_http_requests {
	return unless $selector && $server_socket;
	
	# Check for new connections (non-blocking)
	my @ready = $selector->can_read(0);
	return unless @ready;
	
	foreach my $ready_socket (@ready) {
		if ($ready_socket == $server_socket) {
			# Accept new connection
			my $client = $server_socket->accept();
			next unless $client;
			
			# Handle request in non-blocking manner
			handle_client($client);
			$client->close();
		}
	}
}

sub handle_client {
	my ($client) = @_;
	
	my $start_time = time();
	
	# Read HTTP request
	my $request_line = <$client>;
	return unless $request_line;
	
	chomp $request_line;
	my ($method, $path, $protocol) = split(/\s+/, $request_line);
	
	# Read headers
	my %headers;
	my $content_length = 0;
	while (my $header = <$client>) {
		chomp $header;
		last if $header eq '';
		
		if ($header =~ /^Content-Length:\s*(\d+)/i) {
			$content_length = $1;
		}
	}
	
	# Read body if present
	my $body = '';
	if ($content_length > 0) {
		read($client, $body, $content_length);
	}
	
	# Route request
	my $response;
	if ($method eq 'POST' && $path eq '/macro/inject') {
		$response = handle_inject($body, $start_time);
	} elsif ($method eq 'DELETE' && $path =~ m{^/macro/delete}) {
		$response = handle_delete($body);
	} elsif ($method eq 'GET' && $path eq '/macro/list') {
		$response = handle_list();
	} elsif ($method eq 'GET' && $path eq '/macro/stats') {
		$response = handle_stats();
	} else {
		$response = generate_response(404, {error => 'Not Found'});
	}
	
	# Send response
	print $client $response;
}

sub handle_inject {
	my ($body, $start_time) = @_;
	
	eval {
		my $data = decode_json($body);
		my $macro_name = $data->{name} || return generate_response(400, {error => 'Missing macro name'});
		my $macro_definition = $data->{definition} || return generate_response(400, {error => 'Missing macro definition'});
		my $triggers = $data->{triggers} || [];
		my $priority = $data->{priority} || 50;
		
		# Validate macro syntax
		my $validation = validate_macro_syntax($macro_definition);
		unless ($validation->{valid}) {
			return generate_response(400, {
				error => 'Invalid macro syntax',
				details => $validation->{errors}
			});
		}
		
		# Register macro in registry
		$macro_registry{$macro_name} = {
			definition => $macro_definition,
			triggers => $triggers,
			priority => $priority,
			injected_at => time(),
			execution_count => 0,
			success_count => 0,
			failure_count => 0
		};
		
		# Write to dynamic macro file
		write_macro_to_file($macro_name, $macro_definition);
		
		# Reload eventMacro plugin
		reload_event_macros();
		
		my $injection_time = int((time() - $start_time) * 1000);
		
		message "[MacroHotReload] Injected macro: $macro_name (latency: ${injection_time}ms)\n";
		
		return generate_response(200, {
			status => 'success',
			macro_name => $macro_name,
			injection_time_ms => $injection_time,
			active => 1
		});
	};
	
	if ($@) {
		error "[MacroHotReload] Injection error: $@\n";
		return generate_response(500, {error => "Internal error: $@"});
	}
}

sub handle_delete {
	my ($body) = @_;
	
	eval {
		my $data = decode_json($body);
		my $macro_name = $data->{name} || return generate_response(400, {error => 'Missing macro name'});
		
		unless (exists $macro_registry{$macro_name}) {
			return generate_response(404, {error => 'Macro not found'});
		}
		
		# Remove from registry
		delete $macro_registry{$macro_name};
		delete $macro_stats{$macro_name};
		
		# Rewrite macro file without this macro
		rewrite_macro_file();
		
		# Reload eventMacro plugin
		reload_event_macros();
		
		message "[MacroHotReload] Deleted macro: $macro_name\n";
		
		return generate_response(200, {
			status => 'success',
			macro_name => $macro_name,
			deleted_at => time()
		});
	};
	
	if ($@) {
		error "[MacroHotReload] Deletion error: $@\n";
		return generate_response(500, {error => "Internal error: $@"});
	}
}

sub handle_list {
	my @macros = map {
		{
			name => $_,
			priority => $macro_registry{$_}{priority},
			injected_at => $macro_registry{$_}{injected_at},
			execution_count => $macro_registry{$_}{execution_count}
		}
	} keys %macro_registry;
	
	return generate_response(200, {
		status => 'success',
		macros => \@macros,
		count => scalar(@macros)
	});
}

sub handle_stats {
	my %stats;
	
	foreach my $macro_name (keys %macro_registry) {
		my $reg = $macro_registry{$macro_name};
		my $total = $reg->{execution_count} || 1;
		
		$stats{$macro_name} = {
			execution_count => $reg->{execution_count},
			success_count => $reg->{success_count},
			failure_count => $reg->{failure_count},
			success_rate => sprintf("%.2f", ($reg->{success_count} / $total) * 100),
			injected_at => $reg->{injected_at}
		};
	}
	
	return generate_response(200, {
		status => 'success',
		statistics => \%stats
	});
}

sub validate_macro_syntax {
	my ($definition) = @_;
	
	my @errors;
	
	# Check for balanced braces
	my $open_braces = ($definition =~ tr/{//);
	my $close_braces = ($definition =~ tr/}//);
	push @errors, "Unbalanced braces" if $open_braces != $close_braces;
	
	# Check for required automacro structure
	unless ($definition =~ /automacro\s+\w+\s*\{/) {
		push @errors, "Missing automacro block";
	}
	
	# Check for call statement
	unless ($definition =~ /call\s+\w+/) {
		push @errors, "Missing call statement";
	}
	
	# Check for macro block
	unless ($definition =~ /macro\s+\w+\s*\{/) {
		push @errors, "Missing macro block";
	}
	
	return {
		valid => scalar(@errors) == 0,
		errors => \@errors
	};
}

sub write_macro_to_file {
	my ($macro_name, $definition) = @_;
	
	# Append to dynamic macro file
	open my $fh, '>>', $dynamic_macro_file or die "Cannot open $dynamic_macro_file: $!";
	print $fh "\n";
	print $fh "###############################################\n";
	print $fh "# Macro: $macro_name\n";
	print $fh "# Injected: " . scalar(localtime(time())) . "\n";
	print $fh "###############################################\n";
	print $fh "$definition\n";
	close $fh;
}

sub rewrite_macro_file {
	# Rewrite entire file with current registry
	open my $fh, '>', $dynamic_macro_file or die "Cannot write $dynamic_macro_file: $!";
	print $fh "# Dynamic Macros - Generated by MacroHotReload Plugin\n";
	print $fh "# This file is automatically managed. Do not edit manually.\n\n";
	
	foreach my $macro_name (sort keys %macro_registry) {
		print $fh "\n";
		print $fh "###############################################\n";
		print $fh "# Macro: $macro_name\n";
		print $fh "# Injected: " . scalar(localtime($macro_registry{$macro_name}{injected_at})) . "\n";
		print $fh "###############################################\n";
		print $fh $macro_registry{$macro_name}{definition} . "\n";
	}
	
	close $fh;
}

sub reload_event_macros {
	# Trigger eventMacro plugin reload
	Commands::run("reload eventMacro");
	message "[MacroHotReload] Reloaded eventMacro plugin\n";
}

sub track_macro_execution {
	my (undef, $args) = @_;
	my $macro_name = $args->{macro_name};
	my $success = $args->{success} || 0;
	
	return unless exists $macro_registry{$macro_name};
	
	$macro_registry{$macro_name}{execution_count}++;
	if ($success) {
		$macro_registry{$macro_name}{success_count}++;
	} else {
		$macro_registry{$macro_name}{failure_count}++;
	}
}

sub generate_response {
	my ($status_code, $data) = @_;
	
	my %status_messages = (
		200 => 'OK',
		400 => 'Bad Request',
		404 => 'Not Found',
		500 => 'Internal Server Error'
	);
	
	my $json = encode_json($data);
	my $status_msg = $status_messages{$status_code} || 'Unknown';
	
	my $response = "HTTP/1.1 $status_code $status_msg\r\n";
	$response .= "Content-Type: application/json\r\n";
	$response .= "Content-Length: " . length($json) . "\r\n";
	$response .= "Connection: close\r\n";
	$response .= "\r\n";
	$response .= $json;
	
	return $response;
}

sub on_unload {
	if ($hooks) {
		Plugins::delHooks($hooks);
	}
	
	if ($server_socket) {
		$server_socket->close();
		message "[MacroHotReload] HTTP server stopped\n";
	}
	
	message "[MacroHotReload] Plugin unloaded\n";
}

1;
